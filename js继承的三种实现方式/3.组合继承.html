<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<ul>
			<li><a href="https://www.cnblogs.com/humin/p/4556820.html">JS实现继承的几种方式</a></li>
		</ul>
	</body>
</html>
<script type="text/javascript">
	
	// 定义一个动物类
	function Animal (name) {
	  // 属性
	  this.name = name || 'Animal';
	  // 实例方法
	  this.sleep = function(){
	    console.log(this.name + '正在睡觉！');
	  }
	}
	// 原型方法
	Animal.prototype.eat = function(food) {
	  console.log(this.name + '正在吃：' + food);
	};
	/**
	 * 
	 * 组合继承
	 * 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
	 */
	function Cat(name){
	  Animal.call(this);
	  this.name = name || 'Tom';
	}
	Cat.prototype = new Animal();
	
	
	
	Cat.prototype.constructor = Cat;
	
	// Test Code
	var cat = new Cat();
	cat.name;
	cat.sleep();
	console.log(Cat.prototype)
	
//　因此造成了一个问题，SubType.prototype上会存在不必要的，多余的属性。如name,colors属性同时存在于SubType.prototype和SubType中。
</script>